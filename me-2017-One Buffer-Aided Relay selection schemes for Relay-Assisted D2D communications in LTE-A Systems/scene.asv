clc,clear;
%% 场景图仿真
% 基站覆盖范围圆
alpha = 0:pi/50:2*pi;
R_BS = 500;
x_BS = 0;
y_BS = 0;

x_cir_BS = R_BS*cos(alpha) + x_BS;
y_cir_BS = R_BS*sin(alpha) + x_BS;
plot(x_BS,y_BS,'k^','MarkerFaceColor','k');
hold on;
plot(x_cir_BS,y_cir_BS,'c--');
axis equal;
hold on;

% D2D 通信坐标覆盖范围，假设发射方在0,300处，接收方在0,480处，距离180m
x_S = 0;
y_S = 300;
x_D = 0;
y_D = 480;


R_D2D = sqrt((x_D - x_S)^2 +(y_D - y_S)^2 );
x_cir_D2D =  R_D2D*cos(alpha)  + x_S;
y_cir_D2D =  R_D2D*sin(alpha)  + y_S;
plot(x_cir_D2D,y_cir_D2D,'r--');
axis equal;
hold on;

plot(x_S,y_S,'ro','MarkerFaceColor','r');
hold on;
plot(x_D,y_D,'rs','MarkerFaceColor','r');
hold on;
% 随机产生CUE 用户 20个
x = 1000*rand(1,10000) - 500;
y = 1000*rand(1,10000) - 500;
x_CUE_temp = x(x.^2+y.^2<500*500);
y_CUE_temp = y(x.^2+y.^2<500*500);
x_CUE = x_CUE_temp(1:20);
y_CUE = y_CUE_temp(1:20);
scatter(x_CUE,y_CUE,'bx');
hold on;

% 随机产生DUE 用户 10个
x = 2*R_D2D*rand(1,10000) - R_D2D;
y = 2*R_D2D*rand(1,10000) - R_D2D;
x_DUE_temp = x(x.^2+y.^2<R_D2D*R_D2D);
y_DUE_temp = y(x.^2+y.^2<R_D2D*R_D2D);
x_DUE = x_DUE_temp(1:10) + x_S;
y_DUE = y_DUE_temp(1:10) + y_S;
scatter(x_DUE,y_DUE,'mh');
hold on;
axis([-500 500 -500 500]);

%% 基本参数
M_packet = 50;  %包个数 50
M_packet_length = 1024; % 包大小 1024bit
Relay_buffer = 5; % 能存储包个数5
Noise_density = -174; % 噪声功率谱密度 -174dbm/hz    dbm = 10*lg(mw)
Path_loss_exponent = 4; % 路损系数 α
K = 0.01; % 路损常数 K
Power_UE = 24; % 用户的发射功率 24dbm    10^(24/10) mw;
Energy_loss_factor = 0.3; %电池的能量损失30%
T_slot = 1; % 一个时隙时常 1us   1秒=1000毫秒(ms)1秒=1000000 微秒(μs)
SINR_require = 10; % 需要的最低信噪比 10db

Num_CUE = 20; % CUE用户20个
Num_DUE = 10; % DUE用户10个
 
OperaVol = 4; % 中继节点工作电压4V
% 可变参数
bandwidth = 720000; % 带宽720 000 hz = 720khz
R_min = bandwidth*log2(1 + 10);

% 生成中继节点的能量 暂且认为能量无限 0-2000 mAh 随机分布
% 计算所有节点工作时间
RelayEnery = 2000*rand(1,10);
t_residue = zeros(1,10);
for i = 1:1:10
    t_residue(i) = 1000000 * judgeRelayWorkTime(RelayEnery(i),Power_UE,Energy_loss_factor,OperaVol); % us数
end

%% 方法一 随机选择链路 
% array_fastFading =  exprnd(1);  % 均值为1的指数分布
% array_slowFading = lognrnd(0,8); %均值为0，方差为8db的正态对数分布

tranTime = randomSelect(t_residue,Relay_buffer,M_packet,M_packet_length,x_S,x)


%% 方法二 以速率为准则选择链路
data_save = [0 0 0 0 0 0 0 0 0 0]; % 记录节点中的存储数据量的个数
total_send = M_packet*M_packet_length;
total_receive = 0;

m1 = 0;
m2 = 0;

for i = 1:1:1000000000
    array_fastFading =  exprnd(1,1,100000); % 生成指数分布数组,大量数据，取20个
    array_slowFading =  lognrnd(0,8,1,100000); % 生成正态对数分布数组，大量数据，取20个
    
    % 计算所有S和所有中继对CUE用户的SINR
    SINR_SToCue = judgeSINR_StoCue(x_S,y_S,x_CUE,y_CUE,array_fastFading(1:21),array_slowFading(1:21),bandwidth,Power_UE);
    SINR_RToCue = zeros(10,20);
    for relayNum = 1:1:10
        SINR_RToCue(relayNum,:) = judgeSINR_StoCue(x_DUE(relayNum),y_DUE(relayNum),x_CUE,y_CUE,array_fastFading(21*relayNum+1:21*relayNum+21),array_slowFading(21*relayNum+1:21*relayNum+21),bandwidth,Power_UE);
    end
    
    % 计算所有CUE用户SINR
    % S->Relay的SINR
    SINR_SToRelay= zeros(10,20);
    for relayNum = 1:1:10
        SINR_SToRelay(relayNum,:) = judgeSINR_CuetoD(x_S,y_S,x_DUE(relayNum),y_DUE(relayNum),x_CUE,y_CUE,array_fastFading(1000+21*(relayNum-1):1020+21*(relayNum-1)),array_slowFading(1000+21*(relayNum-1):1020+21*(relayNum-1)),bandwidth,Power_UE);
    end
   % Relay->D的SINR
   SINR_RelayToD = zeros(10,20);
    for relayNum = 1:1:10
        SINR_RelayToD(relayNum,:) = judgeSINR_CuetoD(x_DUE(relayNum),y_DUE(relayNum),x_D,y_D,x_CUE,y_CUE,array_fastFading([1500+relayNum-1,2000:2019]),array_slowFading([1500+relayNum-1,2000:2019]),bandwidth,Power_UE);
    end   
    
    % 找传输速率最大的链路
    R_max = 0;
    R_maxloc = 0;
    for relayNum = 1:1:10
        % S-Relay链路速率
        if total_send > 0 % S中还存在数据
            SINR_SToCueDB = 10*log10(SINR_SToCue);
            SINR_SToRelayDB = 10*log10(SINR_SToRelay(relayNum,:));
            % 找到满足信噪比的信道 
            canUsedChannel = intersect(find(SINR_SToCueDB > SINR_require),find(SINR_SToRelayDB > SINR_require));
            SINR_temp = SINR_SToRelay(relayNum,:);
            max_SINR= max(SINR_temp(canUsedChannel));
            if(~isempty(max_SINR))  % 存在满足条件的信道，取最大信噪比
                % 计算传输速率
                R = bandwidth * log2(1 + max_SINR); % bit/s
                if R > R_max
                    R_max = R;
                    R_maxloc = relayNum;
                end
            end
        end
        % Relay->D链路速率
        if data_save(relayNum) ~= 0 % 节点中存储的有数据 ，才会计算该节点
            SINR_RToCueDB = SINR_RToCue(relayNum,:);
            SINR_RelayToDDB = SINR_RelayToD(relayNum,:);
            % 找到满足信噪比的信道 
            canUsedChannel = intersect(find(SINR_RToCueDB > SINR_require),find(SINR_RelayToDDB > SINR_require));
            SINR_temp = SINR_RelayToD(relayNum,:);
            max_SINR= max(SINR_temp(canUsedChannel));
            if(~isempty(max_SINR))  % 存在满足条件的信道，取最大信噪比
                % 计算传输速率
                R = bandwidth * log2(1 + max_SINR); % bit/s
                if R > R_max
                    R_max = R;
                    R_maxloc = relayNum + 10;
                end
            end        
        end
    end
    
    if R_max ~= 0 % 不为0，说明存在链路满足通信要求
        % 计算一个时隙传输的数据数
        tranSize = floor(R_max * (1/1000000));
        if R_maxloc <= 10  % 前向链路
            if total_send <= tranSize % 发送节点数据传完了
                t_tran = total_send/R_min;
                 if data_save(R_maxloc) + total_send <= Relay_buffer * M_packet_length && t_residue(R_maxloc) >= t_tran*1000000
                     data_save(R_maxloc) = data_save(R_maxloc) + total_send;
                     total_send = 0;
                 else
                     m2 = m2 + 1;
                 end
            else
                t_tran = tranSize/R_min;
                if data_save(R_maxloc) + tranSize <= Relay_buffer * M_packet_length && t_residue(R_maxloc) >= t_tran*1000000
                    % 给相应中继增加数据量，并且更新中继节点存储的数据量
                    data_save(R_maxloc) = data_save(R_maxloc) + tranSize;
                    total_send = total_send - tranSize;
                else
                    m2 = m2 + 1;
                end
            end            
        else % 后向链路
            R_maxloc = R_maxloc - 10;
            if tranSize >= data_save(R_maxloc)  % 可以传输的数据量大于存储的数据量
                % 计算传输需要花费的时间
                t_tran = data_save(R_maxloc) / R_max;
                %更新数据
                total_receive = total_receive + data_save(R_maxloc); % 更新总接收到的数据
                data_save(R_maxloc) = 0;    % 更新节点中存储的数据量
                t_residue(R_maxloc) =  t_residue(R_maxloc) - t_tran*1000000; % 更新节点剩余工作时间           
            else
                 total_receive = total_receive + tranSize; % 更新总接收到的数据
                 data_save(R_maxloc) = data_save(R_maxloc) - tranSize;    % 更新节点中存储的数据量
                 t_residue(R_maxloc) =  t_residue(R_maxloc) - 1; % 更新节点剩余工作时间       
            end            
        end
    else
        m1 = m1 +1;
    end
    
    if total_receive >= M_packet*M_packet_length
        total_receive
        i
        m1
        m2
        break;
    end
end

%% 方法三 同时考虑速率，能量，缓存空间选择链路
data_save = [0 0 0 0 0 0 0 0 0 0]; % 记录节点中的存储数据量的个数
total_send = M_packet*M_packet_length;
total_receive = 0;

m1 = 0;
m2 = 0;
for i = 1:1:1000000000
    array_fastFading =  exprnd(1,1,100000); % 生成指数分布数组,大量数据，取20个
    array_slowFading =  lognrnd(0,8,1,100000); % 生成正态对数分布数组，大量数据，取20个
    
    % 计算所有S和所有中继对CUE用户的SINR
    SINR_SToCue = judgeSINR_StoCue(x_S,y_S,x_CUE,y_CUE,array_fastFading(1:21),array_slowFading(1:21),bandwidth,Power_UE);
    SINR_RToCue = zeros(10,20);
    for relayNum = 1:1:10
        SINR_RToCue(relayNum,:) = judgeSINR_StoCue(x_DUE(relayNum),y_DUE(relayNum),x_CUE,y_CUE,array_fastFading(21*relayNum+1:21*relayNum+21),array_slowFading(21*relayNum+1:21*relayNum+21),bandwidth,Power_UE);
    end
    
    % S->Relay的SINR
    SINR_SToRelay= zeros(10,20);
    for relayNum = 1:1:10
        SINR_SToRelay(relayNum,:) = judgeSINR_CuetoD(x_S,y_S,x_DUE(relayNum),y_DUE(relayNum),x_CUE,y_CUE,array_fastFading(1000+21*(relayNum-1):1020+21*(relayNum-1)),array_slowFading(1000+21*(relayNum-1):1020+21*(relayNum-1)),bandwidth,Power_UE);
    end
   % Relay->D的SINR
   SINR_RelayToD = zeros(10,20);
    for relayNum = 1:1:10
        SINR_RelayToD(relayNum,:) = judgeSINR_CuetoD(x_DUE(relayNum),y_DUE(relayNum),x_D,y_D,x_CUE,y_CUE,array_fastFading([1500+relayNum-1,2000:2019]),array_slowFading([1500+relayNum-1,2000:2019]),bandwidth,Power_UE);
    end
    
    % 同时考虑每个节点的剩余能量和剩余空间选出最适合的链路发送
    RateStoR = zeros(1,10);
    RateRtoD = zeros(1,10);
    % 计算每跳链路的权重
    W_StoR = zeros(1,10);
    W_RtoD = zeros(1,10);
    for relayNum = 1:1:10
        % S-Relay链路速率
        if total_send > 0 % S中还存在数据
            SINR_SToCueDB = 10*log10(SINR_SToCue);
            SINR_SToRelayDB = 10*log10(SINR_SToRelay(relayNum,:));
            % 找到满足信噪比的信道 
            canUsedChannel = intersect(find(SINR_SToCueDB > SINR_require),find(SINR_SToRelayDB > SINR_require));
            SINR_temp = SINR_SToRelay(relayNum,:);
            max_SINR= max(SINR_temp(canUsedChannel));
            if(~isempty(max_SINR))  % 存在满足条件的信道，取最大信噪比
                % 计算传输速率
                R = bandwidth * log2(1 + max_SINR); % bit/s
                % 求该节点剩余能量能够发送的数据量
                RelaycanSend = R_min*t_residue(relayNum);
                % 该节点剩余空间还能存储的数据量
                RelaycanSave = Relay_buffer * M_packet - data_save(relayNum);
                % 计算权重
                W_StoR(relayNum) = min(RelaycanSend,RelaycanSave)*R;
                % 保存速率
                RateStoR(relayNum) = R;
            end
        end
        % Relay->D链路速率
        if data_save(relayNum) ~= 0 % 节点中存储的有数据 ，才会计算该节点
            SINR_RToCueDB = SINR_RToCue(relayNum,:);
            SINR_RelayToDDB = SINR_RelayToD(relayNum,:);
            % 找到满足信噪比的信道 
            canUsedChannel = intersect(find(SINR_RToCueDB > SINR_require),find(SINR_RelayToDDB > SINR_require));
            SINR_temp = SINR_RelayToD(relayNum,:);
            max_SINR= max(SINR_temp(canUsedChannel));
            if(~isempty(max_SINR))  % 存在满足条件的信道，取最大信噪比
                % 计算传输速率
                R = bandwidth * log2(1 + max_SINR); % bit/s
                
                % 计算权重 已经存储的数据数*速率
                W_RtoD(relayNum) = data_save(relayNum)*R;
                % 保存速率
                RateRtoD(relayNum) = R;                
            end        
        end
    end
    
    % 选择权重最大的链路进行传输
    [maxWeight,maxLoc] = max([W_StoR W_RtoD]);
    if(maxWeight ~= 0) % 存在可以发送的节点
        if maxLoc <= 10 % S->Relay 链路
            % 计算一个时隙传输的数据数
            tranSize = floor(RateStoR(maxLoc) * (1/1000000));
            if total_send <= tranSize % 发送节点数据传完了
                t_tran = total_send/R_min;
                 if data_save(maxLoc) + total_send <= Relay_buffer * M_packet_length && t_residue(maxLoc) >= t_tran*1000000
                     data_save(maxLoc) = data_save(maxLoc) + total_send;
                     total_send = 0;
                 else
                     m2 = m2 + 1;
                 end
            else
                t_tran = tranSize/R_min;
                if data_save(maxLoc) + tranSize <= Relay_buffer * M_packet_length && t_residue(maxLoc) >= t_tran*1000000
                    % 给相应中继增加数据量，并且更新中继节点存储的数据量
                    data_save(maxLoc) = data_save(maxLoc) + tranSize;
                    total_send = total_send - tranSize;
                else
                    m2 = m2 + 1;
                end
            end                        
        else % Relay->D链路
            maxLoc = maxLoc - 10;
            % 计算一个时隙传输的数据数
            tranSize = floor(RateRtoD(maxLoc) * (1/1000000));
            if tranSize >= data_save(maxLoc)  % 可以传输的数据量大于存储的数据量
                % 计算传输需要花费的时间
                t_tran = data_save(maxLoc) / RateRtoD(maxLoc);
                %更新数据
                total_receive = total_receive + data_save(maxLoc); % 更新总接收到的数据
                data_save(maxLoc) = 0;    % 更新节点中存储的数据量
                t_residue(maxLoc) =  t_residue(maxLoc) - t_tran*1000000; % 更新节点剩余工作时间           
            else
                 total_receive = total_receive + tranSize; % 更新总接收到的数据
                 data_save(maxLoc) = data_save(maxLoc) - tranSize;    % 更新节点中存储的数据量
                 t_residue(maxLoc) =  t_residue(maxLoc) - 1; % 更新节点剩余工作时间       
            end                
        end
    else
        m1 = m1 + 1;
    end
    
    if total_receive >= M_packet*M_packet_length
        total_receive
        i
        m1
        m2
        break;
    end    
end

